{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/statoscope\/01-01-stateandwhen"]}],"sections":[{"estimatedTimeInMinutes":20,"kind":"hero","title":"Create a simple Scope","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a scope object with state member variables representing"},{"type":"text","text":" "},{"type":"text","text":"a part of your app’s status, define the events that may affect"},{"text":" ","type":"text"},{"type":"text","text":"this state, and create a view to display the state."}]}],"chapter":"Tutorials"},{"tasks":[{"anchor":"Create-a-scope","title":"Create a scope","stepsSection":[{"media":null,"code":"StateAndWhen-Counter-02.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a file "},{"code":"Counter.swift","type":"codeVoice"},{"text":" and import the Statoscope library. This is the first step towards creating your counter scope.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Statoscope helps in defining your app’s state as a separate, modular component that can easily be tested."}]}],"caption":[],"runtimePreview":null,"type":"step"},{"content":[{"inlineContent":[{"type":"text","text":"Define your state using member variables."}],"type":"paragraph"}],"media":null,"runtimePreview":null,"type":"step","code":"StateAndWhen-Counter-02.swift","caption":[{"inlineContent":[{"text":"We suggest using clear, sentence-like naming for state variables. This will make your code more readable and also simplify acceptance testing.","type":"text"}],"type":"paragraph"}]},{"code":"StateAndWhen-Counter-03.swift","type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add the "},{"type":"codeVoice","code":"When"},{"text":" events that can occur in your scope.","type":"text"}]}],"caption":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"When"},{"text":" cases represent the events that trigger state changes. Again, using sentence-like names for these events ensures that your code is both readable and self-explanatory in tests.","type":"text"}],"type":"paragraph"}],"media":null},{"runtimePreview":null,"type":"step","code":"StateAndWhen-Counter-04.swift","caption":[{"type":"paragraph","inlineContent":[{"text":"This method will be responsible for managing how your state evolves when events occur. For now, leave the method skeleton in place — we’ll return to it later.","type":"text"}]}],"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, define the "},{"type":"codeVoice","code":"update"},{"text":" method that will contain your business logic.","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"text":"Before building the real scope implementation via the ","type":"text"},{"code":"update","type":"codeVoice"},{"text":" method, we strongly recommend writing tests on top of the state + when models. However, we are moving forward and introducing tests as the last section of this document","type":"text"}]},{"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"For this counter example, the logic involves updating the count when the user taps either the increment or decrement button, ensuring that the count never drops below zero."}]}],"code":"StateAndWhen-Counter-05.swift","media":null,"runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Now it’s time to implement the "},{"code":"update","type":"codeVoice"},{"text":" method, which contains the state maintenance and business logic of your app’s scope.","type":"text"}]}]},{"runtimePreview":null,"code":"StateAndWhen-Counter-06.swift","content":[{"inlineContent":[{"type":"text","text":"We will soon create a view to display the state. Since we’ll be"},{"text":" ","type":"text"},{"type":"text","text":"using SwiftUI, adopt the "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" protocol and use "},{"type":"codeVoice","code":"@Published"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"for the state variables that the view will observe and reflect."}],"type":"paragraph"}],"caption":[],"type":"step","media":null}],"contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Scopes in Statoscope represent self-contained sections of your app’s logic, managing state and reacting to user or system-driven events. Each scope contains its own member variables to track state, an "},{"type":"codeVoice","code":"update"},{"text":" function to handle the defined events (called ","type":"text"},{"type":"codeVoice","code":"When"},{"text":" cases), and can communicate with views or other components.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A simple use case is a counter, where we want to display the count value and allow the user to increment or decrement it by tapping buttons."}]}]}]},{"title":"Create your view","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Now that we’ve set up the scope, it’s time to build the view that will interact with this state. Using SwiftUI, we will create a simple view that displays the current count and provides buttons to increment or decrement the value. This will allow the user to interact with the scope’s state."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The view will automatically update when the state changes, thanks to the "},{"type":"codeVoice","code":"ObservableObject"},{"text":" protocol and ","type":"text"},{"code":"@Published","type":"codeVoice"},{"text":" properties.","type":"text"}]}],"mediaPosition":"trailing"}],"stepsSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s create our view. SwiftUI’s declarative syntax will help you define this easily and make your source code straightforward."}]}],"caption":[],"code":"StateAndWhen-CounterView-01.swift","type":"step","runtimePreview":"StateAndWhen-CounterView-01.png","media":null},{"content":[{"inlineContent":[{"text":"Let’s create our view. SwiftUI’s declarative syntax will help you define this easily and make your source code straightforward.","type":"text"}],"type":"paragraph"}],"type":"step","runtimePreview":null,"media":null,"caption":[],"code":"StateAndWhen-CounterView-02.swift"},{"code":"StateAndWhen-CounterView-03.swift","runtimePreview":null,"media":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"In case you prefer a higher decoupling between state and view, adopt your common abstraction policy. Take a look at our preferred for inspiration:","type":"text"}]}],"caption":[]}],"anchor":"Create-your-view"},{"contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"StatoscopeTesting is provided as part of the Statoscope library."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"One of the main goals of the Statoscope architecture is to achieve"},{"type":"text","text":" "},{"inlineContent":[{"text":"ACCEPTANCE AS CODE","type":"text"}],"type":"strong"},{"text":". This means your tests will closely align with the user’s acceptance criteria, making the testing process more intuitive and reflective of real user scenarios.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Please notice how we’ve been’ using sentence-like state variables such as “subjectVerbDescription”. Therefore "},{"code":"When","type":"codeVoice"},{"type":"text","text":" cases naming results in a test description that mirrors an acceptance criteria definition."}]}]}],"anchor":"Write-tests-and-acceptance-criterias","stepsSection":[{"type":"step","content":[{"inlineContent":[{"type":"text","text":"Create your test and import the StatoecopeTesting library"}],"type":"paragraph"}],"runtimePreview":null,"media":null,"caption":[],"code":"StateAndWhen-CounterTests-01.swift"},{"code":"StateAndWhen-CounterTests-02.swift","caption":[],"runtimePreview":null,"type":"step","media":null,"content":[{"inlineContent":[{"type":"text","text":"Start providing an initial state for your State Scope with the GIVEN helper"}],"type":"paragraph"}]},{"runtimePreview":null,"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Keep writing synchronous events and their effects on the Scope state."}]}],"media":null,"code":"StateAndWhen-CounterTests-03.swift"},{"type":"step","code":"StateAndWhen-CounterTests-04.swift","media":null,"content":[{"inlineContent":[{"type":"text","text":"‼️‼️ Don’t forget to call the "},{"type":"codeVoice","code":"runTests"},{"type":"text","text":" method"}],"type":"paragraph"}],"runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"text":"Run the test to ensure the implementation works, and check if test description matches some human-readable acceptance criteria, it’d be great for all project collaborators or your future self.","type":"text"}]}]},{"inlineContent":[{"text":"So far so good, we’ve built our first scope implementing a simple counter. The scope manages the state, the view displays it, and the user interacts with the scope through the UI. Furthermore we’ve writte the (integration) tests and acceptance criterias for this scope.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Move to the next chapters to understand "},{"type":"strong","inlineContent":[{"text":"Effects","type":"text"}]},{"text":" and ","type":"text"},{"type":"strong","inlineContent":[{"text":"Scope composition","type":"text"}]},{"text":", where we’ll expand the functionality and connect multiple scopes together for more complex app features.","type":"text"}]}],"title":"Write tests and acceptance criterias"}],"kind":"tasks"},{"abstract":[{"text":"Trigger effects that will get back to your scope as a new When event.","type":"text"}],"title":"State, When and Effects","action":{"overridingTitle":"Get started","isActive":true,"identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-02-StateWhenAndEffects","type":"reference","overridingTitleInlineContent":[{"type":"text","text":"Get started"}]},"kind":"callToAction","featuredEyebrow":"Tutorial"}],"metadata":{"categoryPathComponent":"StatoscopeTutorial","role":"project","category":"Statoscope Architecture","title":"Create a simple Scope"},"identifier":{"url":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen","interfaceLanguage":"swift"},"kind":"project","schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial","doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial\/$volume","doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial\/Tutorials"]],"reference":"doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial","modules":[{"projects":[{"reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen","sections":[{"reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen#Create-a-scope","kind":"task"},{"reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen#Create-your-view","kind":"task"},{"kind":"task","reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen#Write-tests-and-acceptance-criterias"}]},{"sections":[{"reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-02-StateWhenAndEffects#What-is-a-side-effect","kind":"task"},{"kind":"task","reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-02-StateWhenAndEffects#Typed-effects"}],"reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-02-StateWhenAndEffects"},{"reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-03-Middleware","sections":[{"kind":"task","reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-03-Middleware#Logging-middleware"},{"kind":"task","reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-03-Middleware#Built-in-Library-logging"}]},{"sections":[{"kind":"task","reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-04-Injection#Designing-a-Dependency"}],"reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-04-Injection"},{"reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-05-Scopes","sections":[{"kind":"task","reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-05-Scopes#Designing-Scopes"},{"kind":"task","reference":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-05-Scopes#Views-and-Scopes"}]}],"reference":"doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial\/Tutorials"}]},"references":{"doc://Statoscope/tutorials/Statoscope/01-05-Scopes#Views-and-Scopes":{"title":"Views and Scopes","abstract":[{"type":"text","text":"In complex applications, managing all state and events in a single Statostore quickly becomes unsustainable. To scale effectively, we need to split the app’s state and events into separate parts or Scopes. This process can sometimes be straightforward, but other times, developers may feel compelled to separate state and events that are closely tied together due to business logic. In this tutorial, we’ll focus on how to organize app state into different scopes to maintain scalability."}],"url":"\/tutorials\/statoscope\/01-05-scopes#Views-and-Scopes","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-05-Scopes#Views-and-Scopes","role":"pseudoSymbol","type":"section","kind":"section"},"StateAndWhen-CounterView-01.swift":{"fileName":"CounterView","identifier":"StateAndWhen-CounterView-01.swift","content":["import SwiftUI","","struct CounterView: View {","    var body: some View {","        VStack {","            Text(\"0\")","            HStack {","                Button(\"+\") {","                }","                Button(\"-\") {","                }","            }","        }","    }","}"],"syntax":"","type":"file","highlights":[],"fileType":""},"StateAndWhen-CounterTests-04.swift":{"fileName":"CounterTests.swift","content":["import StatoscopeTesting","","final class CounterTest: XCTestCase {","","    func testUserFlow() throws {","        try Counter.GIVEN {","            Counter()","        }","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","        .WHEN(.userTappedIncrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 1)","        .WHEN(.userTappedDecrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","        .WHEN(.userTappedDecrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","        .runTest()","    }","","}"],"identifier":"StateAndWhen-CounterTests-04.swift","type":"file","syntax":"swift","highlights":[{"line":16}],"fileType":"swift"},"doc://Statoscope/tutorials/Statoscope/01-01-StateAndWhen#Create-a-scope":{"kind":"section","abstract":[{"type":"text","text":"Define a scope object with state member variables representing"},{"text":" ","type":"text"},{"type":"text","text":"a part of your app’s status, define the events that may affect"},{"type":"text","text":" "},{"text":"this state, and create a view to display the state.","type":"text"}],"url":"\/tutorials\/statoscope\/01-01-stateandwhen#Create-a-scope","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen#Create-a-scope","role":"pseudoSymbol","type":"section","title":"Create a scope"},"doc://Statoscope/tutorials/Statoscope/01-04-Injection":{"identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-04-Injection","role":"project","kind":"project","estimatedTime":"30min","type":"topic","url":"\/tutorials\/statoscope\/01-04-injection","abstract":[{"type":"text","text":"Learn how to easily design dependencies and inject them into your scopes. Dependency injection simplifies the structure of your code by externalizing the management of dependencies, making your code more modular, testable, and flexible. In this tutorial, we will demonstrate dependency injection using an example of a simple news feed application."}],"title":"Dependency Injection"},"StateAndWhen-Counter-04.swift":{"fileName":"Counter.swift","content":["import Statoscope","","private final class Counter: Scope {","","    var viewDisplaysTotalCount: Int = 0","","    enum When {","        case userTappedIncrementButton","        case userTappedDecrementButton","    }","","    func update(_ when: When) throws {","        \/\/ TODO","    }","}"],"identifier":"StateAndWhen-Counter-04.swift","type":"file","syntax":"swift","highlights":[{"line":11},{"line":12},{"line":13},{"line":14}],"fileType":"swift"},"doc://Statoscope/tutorials/Statoscope/01-01-StateAndWhen#Create-your-view":{"kind":"section","abstract":[{"type":"text","text":"Define a scope object with state member variables representing"},{"text":" ","type":"text"},{"type":"text","text":"a part of your app’s status, define the events that may affect"},{"type":"text","text":" "},{"text":"this state, and create a view to display the state.","type":"text"}],"url":"\/tutorials\/statoscope\/01-01-stateandwhen#Create-your-view","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen#Create-your-view","role":"pseudoSymbol","type":"section","title":"Create your view"},"doc://Statoscope/tutorials/Statoscope/01-05-Scopes":{"type":"topic","kind":"project","title":"Scopes","role":"project","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-05-Scopes","url":"\/tutorials\/statoscope\/01-05-scopes","estimatedTime":"30min","abstract":[{"type":"text","text":"In complex applications, managing all state and events in a single Statostore quickly becomes unsustainable. To scale effectively, we need to split the app’s state and events into separate parts or Scopes. This process can sometimes be straightforward, but other times, developers may feel compelled to separate state and events that are closely tied together due to business logic. In this tutorial, we’ll focus on how to organize app state into different scopes to maintain scalability."}]},"StateAndWhen-Counter-03.swift":{"fileName":"Counter.swift","highlights":[{"line":6},{"line":7},{"line":8},{"line":9},{"line":10}],"identifier":"StateAndWhen-Counter-03.swift","content":["import Statoscope","","private final class Counter: Scope {","","    var viewDisplaysTotalCount: Int = 0","","    enum When {","        case userTappedIncrementButton","        case userTappedDecrementButton","    }","}"],"type":"file","syntax":"swift","fileType":"swift"},"doc://Statoscope/tutorials/Statoscope/01-03-Middleware":{"type":"topic","kind":"project","title":"Single entry point and\/or middlewares","role":"project","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-03-Middleware","url":"\/tutorials\/statoscope\/01-03-middleware","estimatedTime":"30min","abstract":[{"type":"text","text":"Understand how the single entry point enables pretty interesting features"}]},"StateAndWhen-CounterView-01.png":{"identifier":"StateAndWhen-CounterView-01.png","variants":[{"url":"\/images\/StateAndWhen-CounterView-01.png","traits":["1x","light"]}],"alt":null,"type":"image"},"doc://Statoscope/tutorials/Statoscope/01-04-Injection#Designing-a-Dependency":{"title":"Designing a Dependency","abstract":[{"type":"text","text":"Learn how to easily design dependencies and inject them into your scopes. Dependency injection simplifies the structure of your code by externalizing the management of dependencies, making your code more modular, testable, and flexible. In this tutorial, we will demonstrate dependency injection using an example of a simple news feed application."}],"url":"\/tutorials\/statoscope\/01-04-injection#Designing-a-Dependency","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-04-Injection#Designing-a-Dependency","role":"pseudoSymbol","type":"section","kind":"section"},"doc://Statoscope/tutorials/StatoscopeTutorial":{"identifier":"doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial","role":"overview","kind":"overview","type":"topic","url":"\/tutorials\/statoscopetutorial","abstract":[{"type":"text","text":"Statoscope is a small library to build apps with state management,"},{"type":"text","text":" "},{"type":"text","text":"testing, effects management and dependency injection."}],"title":"Statoscope basics"},"doc://Statoscope/tutorials/Statoscope/01-03-Middleware#Built-in-Library-logging":{"kind":"section","abstract":[{"type":"text","text":"Understand how the single entry point enables pretty interesting features"}],"url":"\/tutorials\/statoscope\/01-03-middleware#Built-in-Library-logging","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-03-Middleware#Built-in-Library-logging","role":"pseudoSymbol","type":"section","title":"Built-in Library logging"},"doc://Statoscope/tutorials/Statoscope/01-01-StateAndWhen#Write-tests-and-acceptance-criterias":{"title":"Write tests and acceptance criterias","abstract":[{"type":"text","text":"Define a scope object with state member variables representing"},{"text":" ","type":"text"},{"type":"text","text":"a part of your app’s status, define the events that may affect"},{"type":"text","text":" "},{"text":"this state, and create a view to display the state.","type":"text"}],"url":"\/tutorials\/statoscope\/01-01-stateandwhen#Write-tests-and-acceptance-criterias","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen#Write-tests-and-acceptance-criterias","role":"pseudoSymbol","type":"section","kind":"section"},"StateAndWhen-CounterTests-01.swift":{"fileName":"CounterTests.swift","identifier":"StateAndWhen-CounterTests-01.swift","content":["import StatoscopeTesting","","final class CounterTest: XCTestCase {","","    func testUserFlow() throws {","    }","","}"],"syntax":"swift","type":"file","highlights":[],"fileType":"swift"},"doc://Statoscope/tutorials/Statoscope/01-03-Middleware#Logging-middleware":{"title":"Logging middleware","abstract":[{"type":"text","text":"Understand how the single entry point enables pretty interesting features"}],"url":"\/tutorials\/statoscope\/01-03-middleware#Logging-middleware","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-03-Middleware#Logging-middleware","role":"pseudoSymbol","type":"section","kind":"section"},"doc://Statoscope/tutorials/Statoscope/01-02-StateWhenAndEffects#What-is-a-side-effect":{"kind":"section","abstract":[{"type":"text","text":"Trigger effects that will get back to your scope as a new When event."}],"url":"\/tutorials\/statoscope\/01-02-statewhenandeffects#What-is-a-side-effect","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-02-StateWhenAndEffects#What-is-a-side-effect","role":"pseudoSymbol","type":"section","title":"What is a side effect?"},"StateAndWhen-Counter-06.swift":{"fileName":"Counter.swift","content":["import Statoscope","","private final class Counter: Scope, ObservableObject {","","    @Published var viewDisplaysTotalCount: Int = 0","","    enum When {","        case userTappedIncrementButton","        case userTappedDecrementButton","    }","","    func update(_ when: When) throws {","        switch when {","        case .userTappedIncrementButton:","            viewDisplaysTotalCount += 1","        case .userTappedDecrementButton:","            viewDisplaysTotalCount = max(0, viewDisplaysTotalCount - 1)","        }","    }","}"],"identifier":"StateAndWhen-Counter-06.swift","type":"file","syntax":"swift","highlights":[{"line":3},{"line":5}],"fileType":"swift"},"StateAndWhen-CounterView-03.swift":{"fileName":"CounterViewDecoupled","identifier":"StateAndWhen-CounterView-03.swift","content":["import Statoscope","import SwiftUI","","struct CounterView: View {","    @ObservedObject var model = Counter()","    var body: some View {","        CounterViewDecoupled(","            viewDisplaysTotalCount: \"\\(model.viewDisplaysTotalCount)\",","            action: { model.send($0) }","        )","    }","}","","struct CounterViewDecoupled: View {","    let viewDisplaysTotalCount: String","    let action: (Counter.When) -> Void","    var body: some View {","        VStack {","            Text(viewDisplaysTotalCount)","            HStack {","                Button(\"+\") {","                    action(.userTappedIncrementButton)","                }","                Button(\"-\") {","                    action(.userTappedDecrementButton)","                }","            }","        }","    }","}"],"syntax":"","type":"file","highlights":[],"fileType":""},"doc://Statoscope/tutorials/Statoscope/01-02-StateWhenAndEffects#Typed-effects":{"title":"Typed effects","abstract":[{"type":"text","text":"Trigger effects that will get back to your scope as a new When event."}],"url":"\/tutorials\/statoscope\/01-02-statewhenandeffects#Typed-effects","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-02-StateWhenAndEffects#Typed-effects","role":"pseudoSymbol","type":"section","kind":"section"},"StateAndWhen-CounterTests-02.swift":{"identifier":"StateAndWhen-CounterTests-02.swift","content":["import StatoscopeTesting","","final class CounterTest: XCTestCase {","","    func testUserFlow() throws {","        try Counter.GIVEN {","            Counter()","        }","    }","","}"],"syntax":"swift","fileType":"swift","type":"file","fileName":"CounterTests.swift","highlights":[{"line":6},{"line":7},{"line":8}]},"StateAndWhen-CounterTests-03.swift":{"fileName":"CounterTests.swift","content":["import StatoscopeTesting","","final class CounterTest: XCTestCase {","","    func testUserFlow() throws {","        try Counter.GIVEN {","            Counter()","        }","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","        .WHEN(.userTappedIncrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 1)","        .WHEN(.userTappedDecrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","        .WHEN(.userTappedDecrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","    }","","}"],"identifier":"StateAndWhen-CounterTests-03.swift","type":"file","syntax":"swift","highlights":[{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15}],"fileType":"swift"},"StateAndWhen-Counter-05.swift":{"fileName":"Counter.swift","identifier":"StateAndWhen-Counter-05.swift","content":["import Statoscope","","private final class Counter: Scope {","","    var viewDisplaysTotalCount: Int = 0","","    enum When {","        case userTappedIncrementButton","        case userTappedDecrementButton","    }","","    func update(_ when: When) throws {","        switch when {","        case .userTappedIncrementButton:","            viewDisplaysTotalCount += 1","        case .userTappedDecrementButton:","            viewDisplaysTotalCount = max(0, viewDisplaysTotalCount - 1)","        }","    }","}"],"syntax":"swift","type":"file","highlights":[{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18}],"fileType":"swift"},"doc://Statoscope/tutorials/Statoscope/01-02-StateWhenAndEffects":{"abstract":[{"type":"text","text":"Trigger effects that will get back to your scope as a new When event."}],"kind":"project","title":"State, When and Effects","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-02-StateWhenAndEffects","type":"topic","estimatedTime":"30min","url":"\/tutorials\/statoscope\/01-02-statewhenandeffects","role":"project"},"StateAndWhen-Counter-02.swift":{"fileName":"Counter.swift","content":["import Statoscope","","private final class Counter: Scope {","","    var viewDisplaysTotalCount: Int = 0","}"],"identifier":"StateAndWhen-Counter-02.swift","type":"file","syntax":"swift","highlights":[],"fileType":"swift"},"doc://Statoscope/tutorials/StatoscopeTutorial/Tutorials":{"kind":"article","abstract":[],"url":"\/tutorials\/statoscopetutorial\/tutorials","identifier":"doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial\/Tutorials","role":"article","type":"topic","title":"Tutorials"},"doc://Statoscope/tutorials/Statoscope/01-05-Scopes#Designing-Scopes":{"identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-05-Scopes#Designing-Scopes","url":"\/tutorials\/statoscope\/01-05-scopes#Designing-Scopes","role":"pseudoSymbol","abstract":[{"type":"text","text":"In complex applications, managing all state and events in a single Statostore quickly becomes unsustainable. To scale effectively, we need to split the app’s state and events into separate parts or Scopes. This process can sometimes be straightforward, but other times, developers may feel compelled to separate state and events that are closely tied together due to business logic. In this tutorial, we’ll focus on how to organize app state into different scopes to maintain scalability."}],"title":"Designing Scopes","kind":"section","type":"section"},"StateAndWhen-CounterView-02.swift":{"syntax":"","identifier":"StateAndWhen-CounterView-02.swift","content":["import Statoscope","import SwiftUI","","struct CounterView: View {","    @StateObject var model = Counter()","    var body: some View {","        VStack {","            Text(\"\\(model.viewDisplaysTotalCount)\")","            HStack {","                Button(\"+\") {","                    model.send(.userTappedIncrementButton)","                }","                Button(\"-\") {","                    model.send(.userTappedDecrementButton)","                }","            }","        }","    }","}"],"fileType":"","type":"file","fileName":"CounterView","highlights":[{"line":1},{"line":5},{"line":8},{"line":11},{"line":14}]},"doc://Statoscope/tutorials/Statoscope/01-01-StateAndWhen":{"type":"topic","kind":"project","title":"Create a simple Scope","role":"project","identifier":"doc:\/\/Statoscope\/tutorials\/Statoscope\/01-01-StateAndWhen","url":"\/tutorials\/statoscope\/01-01-stateandwhen","estimatedTime":"20min","abstract":[{"type":"text","text":"Define a scope object with state member variables representing"},{"text":" ","type":"text"},{"text":"a part of your app’s status, define the events that may affect","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"this state, and create a view to display the state."}]}}}