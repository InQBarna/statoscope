{"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"url":"doc:\/\/Statoscope\/documentation\/Statoscope\/Overview-article","interfaceLanguage":"swift"},"seeAlsoSections":[{"generated":true,"title":"Tutorials","identifiers":["doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial"]}],"abstract":[{"type":"text","text":"Explore the core concepts of the Statoscope architecture through examples."}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","anchor":"Statoscope-Basics","text":"Statoscope Basics"},{"level":3,"type":"heading","text":"The Statostore Object","anchor":"The-Statostore-Object"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Statostore"},{"type":"text","text":" object manages your application state, or a portion (scope) of it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is a class object with the following components:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"code":"When","type":"codeVoice"},{"type":"text","text":" type (typically an enum), which defines the events that occur within your application’s scope."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Member variables that represent the state of the application\/scope. These variables should never be modified directly. Instead, the view or other components should send a ","type":"text"},{"type":"codeVoice","code":"When"},{"type":"text","text":" event to the scope, and the scope’s "},{"type":"codeVoice","code":"update"},{"type":"text","text":" method will handle state changes."}]}]},{"content":[{"inlineContent":[{"text":"A public ","type":"text"},{"code":"send","type":"codeVoice"},{"type":"text","text":" method that forwards events for scope processing."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"An internal ","type":"text"},{"type":"codeVoice","code":"update"},{"text":" method that processes the current state and incoming ","type":"text"},{"code":"When","type":"codeVoice"},{"type":"text","text":" event, applying the business logic to produce a new state."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"When"},{"text":" events are processed synchronously, meaning the state is updated immediately after sending an event. Asynchronous tasks, called ","type":"text"},{"type":"strong","inlineContent":[{"text":"Effects","type":"text"}]},{"type":"text","text":", are triggered as side effects. Each effect has a corresponding completion "},{"code":"When","type":"codeVoice"},{"type":"text","text":" event. Thus, a typical asynchronous task introduces two "},{"type":"codeVoice","code":"When"},{"type":"text","text":" events: one to start the effect and one to handle its completion."}]},{"level":4,"text":"Asynchronous Tasks","anchor":"Asynchronous-Tasks","type":"heading"},{"inlineContent":[{"type":"text","text":"The "},{"code":"Statostore","type":"codeVoice"},{"type":"text","text":" object is intentionally designed as a class to manage the lifecycle of ongoing effects. When a "},{"type":"codeVoice","code":"Statostore"},{"text":" instance is released, all associated effects are canceled. This ensures that the lifespan of the object defines the lifespan of the effects.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For asynchronous tasks, the Statoscope object provides:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"code":"enqueue","type":"codeVoice"},{"text":" method to trigger asynchronous tasks during state updates.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"A list of ongoing effects.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Automatic cancellation of effects upon releasing the scope."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"A method to cancel specific ongoing effects."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"heading","text":"State + When","level":2,"anchor":"State-+-When"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Defining a scope means defining at least the State of your application and the When events that may affect it. Some scopes don’t have asynchronous effects, so we will discuss Effects later. See it all together in a simple Statoscope:"}]},{"type":"codeListing","syntax":"swift","code":["fileprivate final class Counter: Statostore {","    ","    \/\/ Define state member variables","    var viewDisplaysTotalCount: Int = 0","    ","    \/\/ Define possible When events affecting state:","    enum When {","        \/\/  case namings are much better with a sentence format:","        case userTappedIncrementButton","        case userTappedDecrementButton","    }","    ","    \/\/ Statoscope conformance forces you to implement the update method:","    func update(_ when: When) throws { throw NotImplemented() }","}"]},{"type":"paragraph","inlineContent":[{"text":"Here we define a common simple application sample commonly used in unidirectional architectures: a counter. It displays the counter and a button to increase or decrease it.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since we’re using it on SwiftUI, see the full Statoscope + View implementation:"}]},{"syntax":"swift","type":"codeListing","code":["fileprivate final class Counter: Statostore, ObservableObject {","    ","    \/\/ Define state member variables, indicate which ones update the ui with Published","    @Published var viewDisplaysTotalCount: Int = 0","    ","    \/\/ Define possible When events affecting state:","    enum When {","        case userTappedIncrementButton","        case userTappedDecrementButton","    }","    ","    func update(_ when: When) throws {","        switch when {","        case .userTappedIncrementButton:","            viewDisplaysTotalCount = viewDisplaysTotalCount + 1","        case .userTappedDecrementButton:","            viewDisplaysTotalCount = max(0, viewDisplaysTotalCount - 1)","        }","    }","}","","fileprivate struct CounterView: View {","    @ObservedObject var model = Counter()","    var body: some View {","        VStack {","            Text(\"\\(model.viewDisplaysTotalCount)\")","            HStack {","                Button(\"+\") {","                    model.send(.userTappedIncrementButton)","                }","                Button(\"-\") {","                    model.send(.userTappedDecrementButton)","                }","            }","        }","    }","}",""]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"State"}],"type":"emphasis"},{"type":"text","text":" is expressed with member variables, as usually done in other SwiftUI design patterns that use ObservableObject. This is an important design decision to make the transition to Statoscope smoother from other development patterns."}],"type":"paragraph"},{"code":["    @Published var viewDisplaysTotalCount: Int = 0"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"When","type":"text"}],"type":"emphasis"},{"type":"text","text":" type enumerates the events that may take place in your app\/screen."}]},{"syntax":"swift","type":"codeListing","code":["enum When {","    case userTappedIncrementButton","    case userTappedDecrementButton","}"]},{"inlineContent":[{"text":"There will usually be 3 big groups of the when cases. See how we intentionally selected a “sentence” format for our cases so it will help you describing the app behavior:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"User driven actions: userTappedIncrementButton, userDismissedAlert…","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"System: systemLoadedTheScreen, systemMovedAppToBackground…","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Effects feedback: next topic is all about effects… will get there soon"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"At the core design principle of the library we’ve added the testability principle, and we want to introduce it as soon as possible. When using sentence-like typing of the State and When events, the fact that the whens are an enum, and using some testing sugar helpers included in the library, testing looks as straightforward as this:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["final class StatoscopeExample1: XCTestCase {","    func testCounterUserFlow() throws {","        try Counter.GIVEN {","            Counter()","        }","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","        .WHEN(.userTappedIncrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 1)","        .WHEN(.userTappedDecrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","        .WHEN(.userTappedDecrementButton)","        .THEN(\\.viewDisplaysTotalCount, equals: 0)","        .runTest()","    }","}"]},{"inlineContent":[{"text":"These test description accomplishes several things:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Describes the behavior of the application: accomplishing ACCEPTANCE AS CODE"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Provides an out-of-the-box testing coverage"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Documents common and supported scenarios. See it further in the testing section and using FORK"}]}]}],"type":"unorderedList"},{"anchor":"State-+-When--+-Effect","level":2,"type":"heading","text":"State + When … + Effect"},{"inlineContent":[{"type":"text","text":"Side effects of our source code are events that may result in later state changes. These Effects are important to the Statoscope architecture. To keep using the pattern used until now (State[N] + Event[N] = State[N+1]), we will split an asynchronous task as 2 different When cases: the one that starts the asynchronous task, and the one receiving of the asynchronous result."}],"type":"paragraph"},{"inlineContent":[{"text":"Let’s see an example, but we will start by looking at the tests first:","type":"text"}],"type":"paragraph"},{"code":["func testCounterExample2UserFlow() throws {","    try Counter.GIVEN {","        Counter()","    }","    .THEN(\\.viewDisplaysTotalCount, equals: 0)","    .THEN(\\.viewShowsLoadingAndDisablesButtons, equals: false)","    \/\/ Increment","    .WHEN(.userTappedIncrementButton)","    .THEN(\\.viewDisplaysTotalCount, equals: 1)","    .THEN(\\.viewShowsLoadingAndDisablesButtons, equals: true)","    .WHEN(.networkPostCompleted(DTO(count: 1)))","    .THEN(\\.viewDisplaysTotalCount, equals: 1)","    .THEN(\\.viewShowsLoadingAndDisablesButtons, equals: false)","    .runTest()","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"We hope the test above explains the behavior of the current example, it’s one of the main goals of the Statoscope architecture. Now, let’s take a look at the scope:"}],"type":"paragraph"},{"code":["static func buildURLRequestPosting(dto: Example2.DTO) throws -> URLRequest {","    guard let url = URL(string: \"http:\/\/statoscope.com\") else {","        fatalError()","    }","    var request = URLRequest(url: url)","    request.setValue(\"application\/json\", forHTTPHeaderField: \"Content-Type\")","    request.httpMethod = \"POST\"","    request.httpBody = try JSONEncoder().encode(dto)","    return request","}","","struct DTO: Codable {","    let count: Int","}","","final class Counter: Statostore, ObservableObject {","    ","    @Published var viewDisplaysTotalCount: Int = 0","    @Published var viewShowsLoadingAndDisablesButtons: Bool = false","    ","    enum When {","        case userTappedIncrementButton","        case userTappedDecrementButton","        case networkPostCompleted(DTO)","    }","    ","    func update(_ when: When) throws {","        switch when {","        case .userTappedIncrementButton:","            viewDisplaysTotalCount = viewDisplaysTotalCount + 1","            viewShowsLoadingAndDisablesButtons = true","            enqueue(","                AnyEffect {","                    let request = try buildURLRequestPosting(dto: DTO(count: self.viewDisplaysTotalCount))","                    let resDTO = try JSONDecoder().decode(DTO.self, from: try await URLSession.shared.data(for: request).0)","                    return When.networkPostCompleted(resDTO)","                }","            )","        case .userTappedDecrementButton:","            guard viewDisplaysTotalCount > 0 else {","                return","            }","            viewDisplaysTotalCount = viewDisplaysTotalCount - 1","            viewShowsLoadingAndDisablesButtons = true","            \/** Same enqueue pattern as in userTappedIncrementButton*\/","        case .networkPostCompleted(let remoteCounter):","            viewShowsLoadingAndDisablesButtons = false","            viewDisplaysTotalCount = remoteCounter.count","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above we trigger an anonymous effect using the enqueue method. The Statoscope library heavily relies on Apple’s concurrency library, it MUST be used to implement your own Effects."},{"type":"text","text":" "},{"text":"However it’s recommended to use typed (non-anonymous effects) to achieve: testability, cancellability and observability. See how to do it:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define an Equatable Effect:"}]}]}],"type":"orderedList"},{"syntax":"swift","type":"codeListing","code":["struct NetworkEffect<Response: Decodable>: Effect {","    let request: URLRequest","    func runEffect() async throws -> Response {","        try JSONDecoder().decode(Response.self, from: try await URLSession.shared.data(for: request).0)","    }","}"]},{"start":2,"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Use it in your update method","type":"text"}]}]}]},{"syntax":"swift","code":["func update(_ when: When) throws {","    switch when {","    case .userTappedIncrementButton:","        viewDisplaysTotalCount = viewDisplaysTotalCount + 1","        viewShowsLoadingAndDisablesButtons = true","        enqueue(","            NetworkEffect<DTO>(request: request)","                .map(When.networkPostCompleted)","        )","        \/** … *\/","    }","}"],"type":"codeListing"},{"start":3,"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Now you can test not only state changes but also effects triggering. Please note Effects in a test environment are not executed, they’re just added to an enqueued list to check correct enqueueing, but never executed. Subsequent WHEN execution will clean up the queue. See how to test our example:","type":"text"}]}]}],"type":"orderedList"},{"syntax":"swift","type":"codeListing","code":[".WHEN(.userTappedDecrementButton)",".THEN { sut in","    XCTAssertEqualEffects(sut, NetworkEffect<DTO>(request: try buildURLRequestPosting(dto: DTO(count: 1))))","}"]},{"items":[{"content":[{"inlineContent":[{"text":"And you can also read which ongoing effects are in the current state, and\/or cancel them:","type":"text"}],"type":"paragraph"}]}],"type":"orderedList","start":4},{"code":["        func update(_ when: When) throws {","            switch when {","            case .userTappedIncrementButton:","                viewDisplaysTotalCount = viewDisplaysTotalCount + 1","                viewShowsLoadingAndDisablesButtons = true","                if nil != erasedEffects.first(where: { $0 is NetworkEffect<DTO> }) {","                    cancelEffect { $0 is NetworkEffect<DTO> }","                }","                enqueue(","                    NetworkEffect<DTO>(request: request)","                        .map(When.networkPostCompleted)","                )","                \/** … *\/","            }","        }"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"We’ve covered the basic of triggering, reading, canceling and testing Effects on Statoscope. In the following topics we’ll discuss some advanced usages and tricks for great Effects programming","type":"text"}],"type":"paragraph"},{"anchor":"App-state-as-Statoscope-composition-Superscope-+-Subscope","type":"heading","level":2,"text":"App state as Statoscope composition: Superscope + Subscope"},{"type":"paragraph","inlineContent":[{"type":"text","text":"TODO: …"}]}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/statoscope\/overview-article"]}],"metadata":{"modules":[{"name":"Statoscope"}],"title":"Overview","role":"article","roleHeading":"Article"},"hierarchy":{"paths":[["doc:\/\/Statoscope\/documentation\/Statoscope"]]},"kind":"article","sections":[],"references":{"doc://Statoscope/tutorials/StatoscopeTutorial":{"identifier":"doc:\/\/Statoscope\/tutorials\/StatoscopeTutorial","role":"overview","kind":"overview","type":"topic","url":"\/tutorials\/statoscopetutorial","abstract":[{"type":"text","text":"Statoscope is a small library to build apps with state management,"},{"type":"text","text":" "},{"type":"text","text":"testing, effects management and dependency injection."}],"title":"Statoscope basics"},"doc://Statoscope/documentation/Statoscope":{"role":"collection","abstract":[{"type":"text","text":"A lightweight library for managing state in iOS applications, designed with simplicity, testability, and scalability in mind."}],"identifier":"doc:\/\/Statoscope\/documentation\/Statoscope","type":"topic","url":"\/documentation\/statoscope","kind":"symbol","title":"Statoscope"}}}